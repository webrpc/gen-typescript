{{define "server"}}

{{- $services := .Services -}}
{{- $typeMap := .TypeMap -}}

{{- if $services}}
//
// Server handler
//
{{range $_, $service := $services }}
export const serve{{$service.Name}}Rpc = async <Context>(service: {{$service.Name}}Server<Context>, ctx: Context, urlPath: string, body: any) => {
  if (!urlPath.startsWith('/rpc/')) return null
  const parts = urlPath.split('/').filter(Boolean)
  if (parts.length !== 3 || parts[0] !== 'rpc' || parts[1] !== '{{$service.Name}}') return null
  const method = parts[2]
  try {
    const result = await dispatch{{$service.Name}}Request(service, ctx, method, body)
    return {
      method,
      status: 200,
      headers: { [WebrpcHeader]: WebrpcHeaderValue, 'Content-Type': 'application/json' },
      body: result ?? {}
    }
  } catch (err: any) {
    if (err instanceof WebrpcError) {
      const status = err.status || 400
      return {
        method,
        status,
        headers: { [WebrpcHeader]: WebrpcHeaderValue, 'Content-Type': 'application/json' },
        body: err
      }
    } else {
      return {
        method,
        status: 400,
        headers: { [WebrpcHeader]: WebrpcHeaderValue, 'Content-Type': 'application/json' },
        body: new WebrpcError({ message: err?.message })
      }
    }
  }
}

const dispatch{{$service.Name}}Request = async <Context>(service: {{$service.Name}}Server<Context>, ctx: Context, method: string, payload: any) => {
  switch (method) {
  {{- range $_, $method := $service.Methods}}
    case '{{$method.Name}}':
    {{- range $_, $input := $method.Inputs }}
      {{- if $method.Succinct }}
      if (payload && !validateType(payload, "{{template "jsType" dict "Type" $input.Type "TypeMap" $typeMap}}")) {
        throw new WebrpcBadRequestError({ cause: "invalid argument: {{ $input.Name }}" })
      }
      {{- else }}
      {{- if not $input.Optional}}
      if (!("{{ $input.Name }}" in payload)) {
        throw new WebrpcBadRequestError({ cause: "missing argument `{{ $input.Name }}`" })
      }
      {{end -}}

      if ("{{ $input.Name }}" in payload && !validateType(payload["{{ $input.Name }}"], "{{template "jsType" dict "Type" $input.Type "TypeMap" $typeMap}}")) {
        throw new WebrpcBadRequestError({ cause: "invalid argument: {{ $input.Name }}" })
      }
      {{- end}}
      {{- end}}
      return service.{{firstLetterToLower $method.Name}}(ctx, payload || {})
  {{end}}
    default:
      throw new WebrpcBadRouteError({ cause: 'method not found' })
  }
}

{{- end}}
{{end -}}
{{end}}
