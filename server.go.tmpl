{{define "server"}}

{{- $services := .Services -}}
{{- $typeMap := .TypeMap -}}

{{- if $services}}
//
// Server
//

export class WebRPCError extends Error {
    statusCode?: number

    constructor(msg: string = "error", statusCode?: number) {
        super("webrpc error: " + msg);

        Object.setPrototypeOf(this, WebRPCError.prototype);

        this.statusCode = statusCode;
    }
}

import { IncomingMessage, ServerResponse } from 'http'

    {{- range $_, $service := $services }}

        export type {{$service.Name}}Service = {
            {{range $_, $method := $service.Methods}}
                {{$method.Name}}: (args: {{$method.Name}}Args) => {{$method.Name}}Return | Promise<{{$method.Name}}Return>
            {{end}}
        }

        export const create{{$service.Name}}Handler = (serviceImplementation: {{$service.Name}}Service) => {
            // returns a Node.js http handler function
            return async (req: any, res: ServerResponse) => {
                // Only handle POST /rpc/* paths
                const url = req.url || ''
                if (req.method !== 'POST' || !url.startsWith('/rpc/')) {
                    return // let outer framework decide 404 vs next()
                }

                // collect body (support frameworks that already parsed body)
                let body: any = req.body
                if (body === undefined) {
                    let raw = ''
                    try {
                        await new Promise<void>((resolve, reject) => {
                            req.on('data', (chunk: any) => { raw += chunk })
                            req.on('end', () => resolve())
                            req.on('error', reject)
                        })
                    } catch (e) {
                        res.statusCode = 400
                        res.end('webrpc error: invalid body')
                        return
                    }

                    try {
                        body = raw.length ? JSON.parse(raw) : undefined
                    } catch (_e) {
                        res.statusCode = 400
                        res.end('webrpc error: invalid json')
                        return
                    }
                }

                res.setHeader(WebrpcHeader, WebrpcHeaderValue)

                if (!body) {
                    res.statusCode = 400
                    res.end('webrpc error: missing body')
                    return
                }

                // dispatch
                switch(url) {
                    {{range $_, $method := $service.Methods}}

                    case "/rpc/{{$service.Name}}/{{$method.Name}}": {                        
                        try {
                            {{ range $_, $input := $method.Inputs }}
                                {{- if not $input.Optional}}
                                    if (!("{{ $input.Name }}" in req.body)) {
                                        throw new WebRPCError("Missing Argument `{{ $input.Name }}`")
                                    }
                                {{end -}}

                                if ("{{ $input.Name }}" in req.body && !validateType(req.body["{{ $input.Name }}"], "{{template "jsType" dict "Type" $input.Type "TypeMap" $typeMap}}")) {
                                    throw new WebRPCError("Invalid Argument: {{ $input.Name }}")
                                }
                            {{end}}

                            const response = await serviceImplementation["{{$method.Name}}"](body);

                            {{ range $_, $output := $method.Outputs}}
                                if (!("{{ $output.Name }}" in response)) {
                                    throw new WebRPCError("internal", 500);
                                }
                            {{end}}

                            res.statusCode = 200
                            res.setHeader('Content-Type', 'application/json')
                            res.end(JSON.stringify(response));
                        } catch (err) {
                            if (err instanceof WebRPCError) {
                                const statusCode = err.statusCode || 400
                                const message = err.message
                                res.statusCode = statusCode
                                res.setHeader('Content-Type', 'application/json')
                                res.end(JSON.stringify({ msg: message, status: statusCode, code: "" }))
                                return
                            }

                            if (err instanceof Error && err.message) {
                                res.statusCode = 400
                                res.end(err.message)
                                return
                            }

                            res.statusCode = 400
                            res.end()
                        }
                    }

                    return
                    {{end}}

                    default: {
                        // Not ours; do nothing so outer framework can continue
                        return
                    }
                }
            }
        };
    {{- end}}
{{end -}}
{{end}}
