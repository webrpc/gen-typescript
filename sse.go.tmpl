{{ define "sse" }}
const sseResponse = async (
    res: Response,
    options: WebrpcStreamOptions<any>
) => {
    const {onMessage, onOpen, onClose, onError} = options;

    if (!res.ok) {
        try {
            await buildResponse(res);
        } catch (error) {
            onError(error as WebrpcError);
        }
        return;
    }

    if (!res.body) {
        onError(
            WebrpcBadResponseError.new({
                status: res.status,
                cause: "Invalid response, missing body",
            })
        );
        return;
    }

    onOpen && onOpen();

    const reader = res.body.getReader();
    const decoder = new TextDecoder();
    let buffer = "";
    const timeout = (10 + 1) * 1000;

    while (true) {
        let value;
        let done;
        try {
            //@ts-ignore
            ({value, done} = await Promise.race([
                reader.read(),
                new Promise((_, reject) =>
                    setTimeout(
                        () =>
                            reject(WebrpcStreamLostError.new({cause: "Stream timed out"})),
                        timeout
                    )
                ),
            ]));
            buffer += decoder.decode(value, {stream: true});
        } catch (error) {
            let message = "";
            if (error instanceof Error) {
                message = error.message;
            }

            if (error instanceof WebrpcStreamLostError) {
                onError(error);
            } else if (error instanceof DOMException && error.name === "AbortError") {
                onError(
                    WebrpcRequestFailedError.new({
                        message: "AbortError",
                        cause: `AbortError: ${message}`,
                    })
                );
            } else {
                onError(
                    WebrpcStreamLostError.new({
                        cause: `reader.read(): ${message}`,
                    })
                );
            }
            return;
        }

        let lines = buffer.split("\n");
        for (let i = 0; i < lines.length - 1; i++) {
            if (lines[i].length == 0) {
                continue;
            }
            try {
                let data = JSON.parse(lines[i]);
                if (data.hasOwnProperty("webrpcError")) {
                    const error = data.webrpcError;
                    const code: number = typeof error.code === "number" ? error.code : 0;
                    onError((webrpcErrorByCode[code] || WebrpcError).new(error));
                } else {
                    onMessage(data);
                }
            } catch (error) {
                let message = "";
                if (error instanceof Error) {
                    message = error.message;
                }
                onError(
                    WebrpcBadResponseError.new({
                        status: res.status,
                        cause: `JSON.parse(): ${message}`,
                    })
                );
            }
        }

        if (!done) {
            buffer = lines[lines.length - 1];
            continue;
        }

        onClose && onClose();
        return;
    }
};
{{ end }}