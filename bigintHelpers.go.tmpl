{{define "bigintHelpers"}}
{{- $schema := .Schema -}}
{{- $opts := .Opts -}}

// TODOXXX NOTE: this can be generated from the tempalte itself.. no need for a helper ..
const SERVICE_METHOD_TYPES: { [service: string]: { [method: string]: [string, string] } } = {
  'Example': {
    GetUser: ['GetUserRequest', 'GetUserResponse'],
    GetArticle: ['GetArticleRequest', 'GetArticleResponse'],
    Ping: ['PingRequest', 'PingResponse']
  }
}

const BIG_INT_FIELDS: { [typ: string]: (string | [string, string])[] } = {
{{- $big := SchemaBigIntFieldsByType $schema }}
{{- $n := len $big -}}
{{- $state := dict "i" 0 -}}
{{- range $typeName, $entries := $big }}
  {{$typeName}}: [
    {{- range $i, $e := $entries -}}
      {{- if $i}}, {{end -}}
      {{- if and (not (isString $e)) (eq (len $e) 2) -}}['{{ index $e 0 }}', '{{ index $e 1 }}']{{else}}'{{$e}}'{{end}}
    {{- end -}}
  ]{{ $i := index $state "i" }}{{ if lt (add $i 1) $n }},{{ end }}
  {{- set $state "i" (add $i 1) -}}
{{- end }}
}

// Encode in-place: mutate provided object graph to serialize bigints to strings.
function encodeType(typ: string, obj: any): any {
  if (obj == null || typeof obj !== 'object') return obj
  const descs = BIG_INT_FIELDS[typ] || []
  for (const d of descs) {
    if (Array.isArray(d)) {
      const [fieldName, nestedType] = d
      if (fieldName.endsWith('[]')) {
        const base = fieldName.slice(0, -2)
        const arr = obj[base]
        if (Array.isArray(arr)) {
          for (let i = 0; i < arr.length; i++) arr[i] = encodeType(nestedType, arr[i])
        }
      } else if (obj[fieldName]) {
        obj[fieldName] = encodeType(nestedType, obj[fieldName])
      }
      continue
    }
    if (d.endsWith('[]')) {
      const base = d.slice(0, -2)
      const arr = obj[base]
      if (Array.isArray(arr)) {
        for (let i = 0; i < arr.length; i++) {
          if (typeof arr[i] === 'bigint') arr[i] = arr[i].toString()
        }
      }
      continue
    }
    if (typeof obj[d] === 'bigint') obj[d] = obj[d].toString()
  }
  return obj
}

// Decode in-place: mutate object graph; throw if expected numeric string is invalid.
function decodeType(typ: string, obj: any): any {
  if (obj == null || typeof obj !== 'object') return obj
  const descs = BIG_INT_FIELDS[typ] || []
  for (const d of descs) {
    if (Array.isArray(d)) {
      const [fieldName, nestedType] = d
      if (fieldName.endsWith('[]')) {
        const base = fieldName.slice(0, -2)
        const arr = obj[base]
        if (Array.isArray(arr)) {
          for (let i = 0; i < arr.length; i++) arr[i] = decodeType(nestedType, arr[i])
        }
      } else if (obj[fieldName]) {
        obj[fieldName] = decodeType(nestedType, obj[fieldName])
      }
      continue
    }
    if (d.endsWith('[]')) {
      const base = d.slice(0, -2)
      const arr = obj[base]
      if (Array.isArray(arr)) {
        for (let i = 0; i < arr.length; i++) {
          const v = arr[i]
          if (typeof v === 'string') {
            try { arr[i] = BigInt(v) } catch (e) { throw WebrpcBadResponseError.new({ cause: `Invalid bigint value for ${base}[${i}]: ${v}` }) }
          }
        }
      }
      continue
    }
    const v = obj[d]
    if (typeof v === 'string') {
      try { obj[d] = BigInt(v) } catch (e) { throw WebrpcBadResponseError.new({ cause: `Invalid bigint value for ${d}: ${v}` }) }
    }
  }
  return obj
}

// Encode object of given root type to JSON with BigInts converted to decimal strings.
const JsonEncode = <T = any>(typ: string, obj: T): string => {
  return JSON.stringify(encodeType(typ, obj))
}

// Decode data (JSON string or already-parsed object) and convert declared BigInt string fields back to BigInt.
const JsonDecode = <T = any>(typ: string, data: string | any): T => {
  let parsed: any = data
  if (typeof data === 'string') {
    try { parsed = JSON.parse(data) } catch (err) {
      throw WebrpcBadResponseError.new({ cause: `JsonDecode: JSON.parse failed: ${(err as Error).message}` })
    }
  }
  return decodeType(typ, parsed) as T
}

{{end}}
