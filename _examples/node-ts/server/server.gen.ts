/* eslint-disable */
// node-ts v1.0.0 21701cae51b73d035bf2180831cdb38220bbbccc
// --
// Code generated by webrpc-gen@v0.28.1-1-ge2b37ad with ../../../gen-typescript generator. DO NOT EDIT.
//
// webrpc-gen -schema=service.ridl -target=../../../gen-typescript -server -out=./server/server.gen.ts

export const WebrpcHeader = "Webrpc"

export const WebrpcHeaderValue = "webrpc@v0.28.1-1-ge2b37ad;gen-typescript@unknown;node-ts@v1.0.0"

// Webrpc description and code-gen version
export const WebrpcVersion = "v1"

// Schema version of your RIDL schema
export const WebrpcSchemaVersion = "v1.0.0"

// Schema hash generated from your RIDL schema
export const WebrpcSchemaHash = "21701cae51b73d035bf2180831cdb38220bbbccc"

type WebrpcGenVersions = {
  webrpcGenVersion: string;
  codeGenName: string;
  codeGenVersion: string;
  schemaName: string;
  schemaVersion: string;
};

export function VersionFromHeader(headers: Headers): WebrpcGenVersions {
  const headerValue = headers.get(WebrpcHeader);
  if (!headerValue) {
    return {
      webrpcGenVersion: "",
      codeGenName: "",
      codeGenVersion: "",
      schemaName: "",
      schemaVersion: "",
    };
  }

  return parseWebrpcGenVersions(headerValue);
}

function parseWebrpcGenVersions(header: string): WebrpcGenVersions {
  const versions = header.split(";");
  if (versions.length < 3) {
    return {
      webrpcGenVersion: "",
      codeGenName: "",
      codeGenVersion: "",
      schemaName: "",
      schemaVersion: "",
    };
  }

  const [_, webrpcGenVersion] = versions[0]!.split("@");
  const [codeGenName, codeGenVersion] = versions[1]!.split("@");
  const [schemaName, schemaVersion] = versions[2]!.split("@");

  return {
    webrpcGenVersion: webrpcGenVersion ?? "",
    codeGenName: codeGenName ?? "",
    codeGenVersion: codeGenVersion ?? "",
    schemaName: schemaName ?? "",
    schemaVersion: schemaVersion ?? "",
  };
}

//
// Types
//

export enum Kind {
  USER = 'USER',
  ADMIN = 'ADMIN'
}

export interface User {
  id: number
  USERNAME: string
  role: Kind
  meta: { [key: string]: any }
  createdAt?: string
}

export interface Page {
  num: number
}

export interface GetArticleRequest {
  articleId: number
}

export interface GetArticleResponse {
  title: string
  content?: string
}

export interface ExampleClient {
  /**
   * @deprecated Use /health endpoint instead.
   */
  ping(headers?: object, signal?: AbortSignal): Promise<PingResponse>
  /**
   * GetUser returns a user by ID.
   */
  getUser(args: GetUserRequest, headers?: object, signal?: AbortSignal): Promise<GetUserResponse>
  /**
   * Get article by id.
   */
  getArticle(req: GetArticleRequest, headers?: object, signal?: AbortSignal): Promise<GetArticleResponse>
}

// TODO: lets switch to names.. Request and Response suffixes ..? .. but maybe it'll break a lot of apps?
// consider adding a flag here for it..? at generation time.. like --compat mode ..

export interface PingRequest {
}

export interface PingResponse {
}

export interface GetUserRequest {
  userId: number
}

export interface GetUserResponse {
  code: number
  user: User
}

// export interface GetArticleArgs {
//   getArticleRequest: GetArticleRequest
// }

// export interface GetArticleReturn {
//   getArticleResponse: GetArticleResponse  
// }



//
// Server
//

// Generic server interface accepting a user-defined context object C which
// will be provided as the first argument to every RPC handler.
export interface ExampleServer<Context = unknown> {
  ping(ctx: Context, req: PingRequest): Promise<PingResponse>
  getUser(ctx: Context, req: GetUserRequest): Promise<GetUserResponse>
  getArticle(ctx: Context, req: GetArticleRequest): Promise<GetArticleResponse>
}

export class WebrpcError extends Error {
  statusCode?: number
  constructor(msg: string = "error", statusCode?: number) {
    super("webrpc error: " + msg);
    Object.setPrototypeOf(this, WebrpcError.prototype);
    this.statusCode = statusCode;
  }
}

const JS_TYPES = [
  "bigint",
  "boolean",
  "function",
  "number",
  "object",
  "string",
  "symbol",
  "undefined"
]

const validateKind = (value: any) => {
  if (!("USER" in value) || !validateType(value["USER"], "number")) {
    return false
  }
  if (!("ADMIN" in value) || !validateType(value["ADMIN"], "number")) {
    return false
  }
  return true
}

const validateUser = (value: any) => {
  if (!("id" in value) || !validateType(value["id"], "number")) {
    return false
  }
  if (!("USERNAME" in value) || !validateType(value["USERNAME"], "string")) {
    return false
  }
  if (!("role" in value) || !validateType(value["role"], "Kind")) {
    return false
  }
  if (!("meta" in value) || !validateType(value["meta"], "object")) {
    return false
  }
  if (!("-" in value) || !validateType(value["-"], "number")) {
    return false
  }
  if ("createdAt" in value && !validateType(value["createdAt"], "string")) {
    return false
  }
  return true
}

const validatePage = (value: any) => {
  if (!("num" in value) || !validateType(value["num"], "number")) {
    return false
  }
  return true
}

const validateGetArticleRequest = (value: any) => {
  if (!("articleId" in value) || !validateType(value["articleId"], "number")) {
    return false
  }
  return true
}

const validateGetArticleResponse = (value: any) => {
  if (!("title" in value) || !validateType(value["title"], "string")) {
    return false
  }
  if ("content" in value && !validateType(value["content"], "string")) {
    return false
  }
  return true
}


const TYPE_VALIDATORS: { [type: string]: (value: any) => boolean } = {
  Kind: validateKind,
  User: validateUser,
  Page: validatePage,
  GetArticleRequest: validateGetArticleRequest,
  GetArticleResponse: validateGetArticleResponse,
}

const validateType = (value: any, type: string) => {
  if (JS_TYPES.indexOf(type) > -1) {
    return typeof value === type;
  }
  const validator = TYPE_VALIDATORS[type];
  if (!validator) {
    return false;
  }
  return validator(value);
}

// -----------------------------------------------------------------------------
// Lightweight, framework-agnostic helpers (added manually for cleaner usage)
// -----------------------------------------------------------------------------
// These helpers provide a tiny dispatch layer so application code (e.g. Fastify,
// Express, native http) can register a single handler without crafting req/res
// shims. They intentionally keep validation minimal â€“ just presence/type checks
// similar to the original generated logic.



// Ultra-thin helper: given full URL and body, resolve & execute if it's an Example RPC.
// Returns null if the URL does not target the Example service (so caller can 404).
export const serveExampleRpc = async <Context>(service: ExampleServer<Context>, ctx: Context, urlPath: string, body: any) => {
  if (!urlPath.startsWith('/rpc/')) return null
  const parts = urlPath.split('/').filter(Boolean)
  if (parts.length !== 3 || parts[0] !== 'rpc' || parts[1] !== 'Example') return null
  const method = parts[2]
  try {
    const result = await dispatchExampleRequest(service, ctx, method, body)
    return {
      method,
      status: 200,
      headers: { [WebrpcHeader]: WebrpcHeaderValue, 'Content-Type': 'application/json' },
      body: result ?? {}
    }
  } catch (err: any) {
    if (err instanceof WebrpcError) {
      const status = err.statusCode || 400
      return {
        method,
        status,
        headers: { [WebrpcHeader]: WebrpcHeaderValue, 'Content-Type': 'application/json' },
        body: { msg: err.message, status, code: '' }
      }
    }
    return {
      method,
      status: 400,
      headers: { [WebrpcHeader]: WebrpcHeaderValue, 'Content-Type': 'application/json' },
      body: { msg: err?.message || 'webrpc error', status: 400, code: '' }
    }
  }
}

// Small pure dispatcher (no framework concepts)
const dispatchExampleRequest = async <Context>(service: ExampleServer<Context>, ctx: Context, method: string, payload: any) => {
  switch (method) {
    case 'Ping':
      return service.ping(ctx, payload || {})
    case 'GetUser':
      if (!payload || typeof payload.userId !== 'number') throw new WebrpcError('Missing or invalid argument `userId`', 400)
      const userResp = await service.getUser(ctx, { userId: payload.userId })
      if (!userResp || typeof userResp.code !== 'number' || !userResp.user) throw new WebrpcError('internal', 500)
      return userResp
    case 'GetArticle':
      if (!payload || typeof payload.articleId !== 'number') throw new WebrpcError('Missing or invalid argument `articleId`', 400)
      return service.getArticle(ctx, { articleId: payload.articleId })
    default:
      throw new WebrpcError('method not found', 404)
  }
}
