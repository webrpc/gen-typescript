/* eslint-disable */
// node-ts v1.0.0 21701cae51b73d035bf2180831cdb38220bbbccc
// --
// Code generated by webrpc-gen@v0.28.1-1-ge2b37ad with ../../../gen-typescript generator. DO NOT EDIT.
//
// webrpc-gen -schema=service.ridl -target=../../../gen-typescript -server -out=./server/server.gen.ts

export const WebrpcHeader = "Webrpc"

export const WebrpcHeaderValue = "webrpc@v0.28.1-1-ge2b37ad;gen-typescript@unknown;node-ts@v1.0.0"

// Webrpc description and code-gen version
export const WebrpcVersion = "v1"

// Schema version of your RIDL schema
export const WebrpcSchemaVersion = "v1.0.0"

// Schema hash generated from your RIDL schema
export const WebrpcSchemaHash = "21701cae51b73d035bf2180831cdb38220bbbccc"

type WebrpcGenVersions = {
    webrpcGenVersion: string;
    codeGenName: string;
    codeGenVersion: string;
    schemaName: string;
    schemaVersion: string;
};

export function VersionFromHeader(headers: Headers): WebrpcGenVersions {
    const headerValue = headers.get(WebrpcHeader);
    if (!headerValue) {
        return {
            webrpcGenVersion: "",
            codeGenName: "",
            codeGenVersion: "",
            schemaName: "",
            schemaVersion: "",
        };
    }

    return parseWebrpcGenVersions(headerValue);
}

function parseWebrpcGenVersions(header: string): WebrpcGenVersions {
    const versions = header.split(";");
    if (versions.length < 3) {
        return {
            webrpcGenVersion: "",
            codeGenName: "",
            codeGenVersion: "",
            schemaName: "",
            schemaVersion: "",
        };
    }

    const [_, webrpcGenVersion] = versions[0]!.split("@");
    const [codeGenName, codeGenVersion] = versions[1]!.split("@");
    const [schemaName, schemaVersion] = versions[2]!.split("@");

    return {
        webrpcGenVersion: webrpcGenVersion ?? "",
        codeGenName: codeGenName ?? "",
        codeGenVersion: codeGenVersion ?? "",
        schemaName: schemaName ?? "",
        schemaVersion: schemaVersion ?? "",
    };
}

//
// Types
//

export enum Kind {
    USER = 'USER',
    ADMIN = 'ADMIN'
}

export interface User {
    id: number
    USERNAME: string
    role: Kind
    meta: { [key: string]: any }
    createdAt?: string
}

export interface Page {
    num: number
}

export interface GetArticleRequest {
    articleId: number
}

export interface GetArticleResponse {
    title: string
    content?: string
}

export interface ExampleClient {
    /**
     * @deprecated Use /health endpoint instead.
     */
    ping(headers?: object, signal?: AbortSignal): Promise<PingReturn>
    /**
     * GetUser returns a user by ID.
     */
    getUser(args: GetUserArgs, headers?: object, signal?: AbortSignal): Promise<GetUserReturn>
    /**
     * Get article by id.
     */
    getArticle(req: GetArticleRequest, headers?: object, signal?: AbortSignal): Promise<GetArticleResponse>
}

// TODO: lets switch to names.. Request and Response suffixes ..? .. but maybe it'll break a lot of apps?
// consider adding a flag here for it..? at generation time.. like --compat mode ..

export interface PingArgs {
}

export interface PingReturn {
}
export interface GetUserArgs {
    userId: number
}

export interface GetUserReturn {
    code: number
    user: User
}
// export interface GetArticleArgs {
//   getArticleRequest: GetArticleRequest
// }

// export interface GetArticleReturn {
//   getArticleResponse: GetArticleResponse  
// }



//
// Server
//

export interface ExampleServer {
    ping(args: PingArgs): Promise<PingReturn>
    getUser(args: GetUserArgs): Promise<GetUserReturn>
    getArticle(req: GetArticleRequest): Promise<GetArticleResponse>
}

export class WebrpcError extends Error {
    statusCode?: number
    constructor(msg: string = "error", statusCode?: number) {
        super("webrpc error: " + msg);
        Object.setPrototypeOf(this, WebrpcError.prototype);
        this.statusCode = statusCode;
    }
}

const JS_TYPES = [
    "bigint",
    "boolean",
    "function",
    "number",
    "object",
    "string",
    "symbol",
    "undefined"
]

const validateKind = (value: any) => {
    if (!("USER" in value) || !validateType(value["USER"], "number")) {
        return false
    }
    if (!("ADMIN" in value) || !validateType(value["ADMIN"], "number")) {
        return false
    }
    return true
}

const validateUser = (value: any) => {
    if (!("id" in value) || !validateType(value["id"], "number")) {
        return false
    }
    if (!("USERNAME" in value) || !validateType(value["USERNAME"], "string")) {
        return false
    }
    if (!("role" in value) || !validateType(value["role"], "Kind")) {
        return false
    }
    if (!("meta" in value) || !validateType(value["meta"], "object")) {
        return false
    }
    if (!("-" in value) || !validateType(value["-"], "number")) {
        return false
    }
    if ("createdAt" in value && !validateType(value["createdAt"], "string")) {
        return false
    }
    return true
}

const validatePage = (value: any) => {
    if (!("num" in value) || !validateType(value["num"], "number")) {
        return false
    }
    return true
}

const validateGetArticleRequest = (value: any) => {
    if (!("articleId" in value) || !validateType(value["articleId"], "number")) {
        return false
    }
    return true
}

const validateGetArticleResponse = (value: any) => {
    if (!("title" in value) || !validateType(value["title"], "string")) {
        return false
    }
    if ("content" in value && !validateType(value["content"], "string")) {
        return false
    }
    return true
}


const TYPE_VALIDATORS: { [type: string]: (value: any) => boolean } = {
    Kind: validateKind,
    User: validateUser,
    Page: validatePage,
    GetArticleRequest: validateGetArticleRequest,
    GetArticleResponse: validateGetArticleResponse,
}

const validateType = (value: any, type: string) => {
    if (JS_TYPES.indexOf(type) > -1) {
        return typeof value === type;
    }
    const validator = TYPE_VALIDATORS[type];
    if (!validator) {
        return false;
    }
    return validator(value);
}

// -----------------------------------------------------------------------------
// Lightweight, framework-agnostic helpers (added manually for cleaner usage)
// -----------------------------------------------------------------------------
// These helpers provide a tiny dispatch layer so application code (e.g. Fastify,
// Express, native http) can register a single handler without crafting req/res
// shims. They intentionally keep validation minimal â€“ just presence/type checks
// similar to the original generated logic.


// Small pure dispatcher (no framework concepts)
const dispatchRequest = async (service: ExampleServer, method: string, payload: any) => {
    switch (method) {
        case 'Ping':
            return service.ping(payload || {})
        case 'GetUser':
            if (!payload || typeof payload.userId !== 'number') throw new WebrpcError('Missing or invalid argument `userId`', 400)
            const userResp = await service.getUser({ userId: payload.userId })
            if (!userResp || typeof userResp.code !== 'number' || !userResp.user) throw new WebrpcError('internal', 500)
            return userResp
        case 'GetArticle':
            if (!payload || typeof payload.articleId !== 'number') throw new WebrpcError('Missing or invalid argument `articleId`', 400)
            return service.getArticle({ articleId: payload.articleId })
        default:
            throw new WebrpcError('method not found', 404)
    }
}

// Ultra-thin helper: given full URL and body, resolve & execute if it's an Example RPC.
// Returns null if the URL does not target the Example service (so caller can 404).
export const handleExampleRpc = async (service: ExampleServer, methodUrl: string, body: any) => {
    if (!methodUrl.startsWith('/rpc/')) return null
    const parts = methodUrl.split('/').filter(Boolean)
    if (parts.length !== 3 || parts[0] !== 'rpc' || parts[1] !== 'Example') return null
    const method = parts[2]
    try {
        const result = await dispatchRequest(service, method, body)
        return {
            method,
            status: 200,
            headers: { [WebrpcHeader]: WebrpcHeaderValue, 'Content-Type': 'application/json' },
            body: result ?? {}
        }
    } catch (err: any) {
        if (err instanceof WebrpcError) {
            const status = err.statusCode || 400
            return {
                method,
                status,
                headers: { [WebrpcHeader]: WebrpcHeaderValue, 'Content-Type': 'application/json' },
                body: { msg: err.message, status, code: '' }
            }
        }
        return {
            method,
            status: 400,
            headers: { [WebrpcHeader]: WebrpcHeaderValue, 'Content-Type': 'application/json' },
            body: { msg: err?.message || 'webrpc error', status: 400, code: '' }
        }
    }
}

// -----------------------------------------------------------------------------
// Node.js (node:http) integration (vanilla, no external framework)
// -----------------------------------------------------------------------------
// This helper mounts the Example RPC service onto a native Node http server.
// It parses JSON bodies (if any) and delegates to `handleExampleRpc`. If the
// request URL does not match the Example RPC pattern, it returns `false` so the
// outer handler can continue handling (e.g. other routes or 404 logic).
// NOTE: This file intentionally remains framework-agnostic. Fastify/Express
// examples should call `handleExampleRpc` directly rather than altering this.
// -----------------------------------------------------------------------------

import type { IncomingMessage, ServerResponse } from 'node:http';

export type HttpHandler = (req: IncomingMessage, res: ServerResponse) => Promise<boolean>;

export function createNodeHttpExampleHandler(service: ExampleServer): HttpHandler {
    return async function nodeHttpExampleHandler(req: IncomingMessage, res: ServerResponse): Promise<boolean> {
        const url = req.url || '';
        if (!url.startsWith('/rpc/')) return false; // not our RPC route

        // Accumulate body (only for methods that may carry a payload). We accept both GET & POST;
        // GET requests simply use an empty object. POST/PUT/PATCH attempt to parse JSON.
        const method = (req.method || 'GET').toUpperCase();
        let rawBody = '';
        if (method === 'POST' || method === 'PUT' || method === 'PATCH') {
            rawBody = await new Promise<string>((resolve, reject) => {
                let data = '';
                req.on('data', (chunk: Buffer) => { data += chunk.toString('utf8'); });
                req.on('end', () => resolve(data));
                req.on('error', reject);
            });
        }

        let parsed: any = {};
        if (rawBody.length > 0) {
            try {
                parsed = JSON.parse(rawBody);
            } catch (e: any) {
                // Malformed JSON
                const status = 400;
                const body = { msg: 'invalid JSON body', status, code: '' };
                res.writeHead(status, { [WebrpcHeader]: WebrpcHeaderValue, 'Content-Type': 'application/json' });
                res.end(JSON.stringify(body));
                return true; // handled
            }
        }

        const result = await handleExampleRpc(service, url, parsed);
        if (result == null) {
            return false; // pattern mismatch (shouldn't happen due to prefix check)
        }
        const payload = JSON.stringify(result.body ?? {});
        res.writeHead(result.status, {
            ...result.headers,
            'Content-Length': Buffer.byteLength(payload)
        });
        res.end(payload);
        return true;
    };
}
